<!DOCTYPE html>
<html>
<!-- Tennis/Pong game by tom@digitalnook.net -->
<head>
	<title>Tennis | DigitalNook</title>
	<link href="/static/styles1.css" rel="stylesheet" type="text/css"/>
	<link href="/static/favicon.ico" rel="shortcut icon" type="favicon/x-icon"/>
	<!-- should scales all elements to viewport size, fix this later  -->
	<!-- Phaser Game Framework ****USE MIN IN RELEASE BUILD****-->
	<script src="/static/scripts/phaser.min.js"></script>
	<!-- my sleep function -->
	<script src="/static/scripts/sleep.js"></script>
	<!-- styles phaser canvas -->
	<style> canvas{border: 3px solid blue;} </style>

</head> 

<body style="resize: both;"> 
	<header>
		<h1>Tennis</h1>
	</header>
	<div id="main" style="margin: 10px; overflow: hidden; display:flex; flex-flow: row wrap; justify-content: center;  ">
		<div id="game" style="flex-shrink: 5; margin-right: 15px"> 
		</div>
		
		<div id="settings">
			<p style="font-weight: bold;">First to 10</p>
			<br/>
			<p id="playerScore"> Your score: 0</p>
			<br/>
			<p id="compScore">Computer's score: 0</p>
		</div>
	</div>
	<footer>
		 <br/>
		<a href="/games">Back to Games</a>
		 <br/>
		 <br/>
	</footer>

<script>
// aliases for DOM elements
const playerScore = document.getElementById("playerScore");
const compScore = document.getElementById("compScore");

let gameState = {};
const config = {
	type: Phaser.AUTO,
	width: 1000,
	height: 600,
	parent: "game",
	backgroundColor: 0xbfbfbf,
	physics: {
		default: "arcade",
		arcade: {
			gravity: {y: 0},
//			debug: true,
		},
	},
	scene: {
		preload: preload,
		create: create,
		update: update
	},
};
//defines phaser game obj from config
const game = new Phaser.Game(config);

// Variables to keep sprite position consistent on resize 
let width = game.config.width;
let height = game.config.height;
const halfHeight = height / 2;
const halfWidth = width / 2;
const width20 = width / 20; 

function preload(){
	this.load.image("ball","/static/images/ball.png");
	this.load.image("playerPaddle", "/static/images/playerPaddle.png");
	this.load.image("compPaddle", "/static/images/compPaddle.png");
	this.load.image("winnerPopup", "/static/images/winnerPopup.png");
	this.load.image("loserPopup", "/static/images/loserPopup.png");
}

function create() {	
	// Makes sprites using preloaded images
	gameState.loserPopup = this.add.image(halfWidth, halfHeight, "loserPopup").setInteractive();
	gameState.winnerPopup = this.add.image(halfWidth, halfHeight, "winnerPopup").setInteractive();
	gameState.loserPopup.setVisible(false);
	gameState.winnerPopup.setVisible(false);

	gameState.playerPaddle = this.physics.add.sprite(width20, halfHeight, "playerPaddle").setScale(0.3).setInteractive();
	gameState.compPaddle = this.physics.add.sprite((width - width20), halfHeight, "compPaddle").setScale(0.3).setInteractive();
	gameState.ball = this.physics.add.sprite(halfWidth, halfHeight, "ball").setScale(0.1).setInteractive();
	
	// player/ball collision
	this.physics.add.collider(gameState.playerPaddle, gameState.ball, function() {
		randNum = Math.random();
		// slight randomness in velocity to make game feel more dynamic)
		
		if(randNum <= 0.5){
			
			if (gameState.playerPaddle.body.velocity.y === 0) {
				gameState.ball.setVelocityY(gameState.playerPaddle.body.velocity.y = 100);		
			} else {
				gameState.ball.setVelocityY(gameState.playerPaddle.body.velocity.y / 1.9);
			}
		}else if (randNum >= 0.5){
			
			if (gameState.playerPaddle.body.velocity.y === 0) {
				gameState.ball.setVelocityY(gameState.playerPaddle.body.velocity.y = -100);		
			} else {
				gameState.ball.setVelocityY(gameState.playerPaddle.body.velocity.y / 1.7);
			}
		}
	});
	
	// comp/ball collision
	this.physics.add.collider(gameState.compPaddle, gameState.ball, function() {
		if (gameState.playerPaddle.y > halfHeight) {
			gameState.ball.setVelocityY(-100 * (Math.random() * 4.5));
		}else if (gameState.playerPaddle.y < halfHeight) {	
			gameState.ball.setVelocityY(100 *(Math.random() * 4.5));	
		}else if (gameState.playerPaddle.y) {
			num = Math.random()
			if (num >= 0.5) {
				gameState.ball.setVelocityY(100 *(Math.random() * 4.5));	
			}
			else {
				gameState.ball.setVelocityY(-100 *(Math.random() * 4.5));	
			}
		}
		
	
	});

	gameState.ball.setBounce(1);
	gameState.ball.setVelocityX(-1000);
	
	// makes paddles unaffected by balls force
	gameState.playerPaddle.body.immovable = true;
	gameState.compPaddle.body.immovable = true;
	

	// creates default keyboard inputs
	gameState.cursors = this.input.keyboard.createCursorKeys();
		
	// mobile controls
	gameState.mobilePointer = this.input.activePointer;

	// ensures sprites never leave game
	gameState.compPaddle.setCollideWorldBounds(true);
	gameState.playerPaddle.setCollideWorldBounds(true);
	gameState.ball.setCollideWorldBounds(true);
	
};
let player = {
	score: 0,	
};
let comp = {
	score: 0,	
};

function update() {
	let newWidth = window.innerWidth / 60
	let newHeight = window.innerHeight / 40
	game.scale.setGameSize(newWidth, newHeight)

	if (player.score < 10 && comp.score < 10){

		// mouse player controls test
		if (gameState.mobilePointer.y > gameState.playerPaddle.y + 50) {
			gameState.playerPaddle.setVelocityY(800);
		} else if (gameState.mobilePointer.y < gameState.playerPaddle.y - 50) {
			gameState.playerPaddle.setVelocityY(-800)
		} else {
			gameState.playerPaddle.setVelocityY(0)
		}


		// desktop player controls
		if (gameState.cursors.down.isDown){
			gameState.playerPaddle.setVelocityY(800);
		}
		else if (gameState.cursors.up.isDown) {
			gameState.playerPaddle.setVelocityY(-800);
		}
		else {
			gameState.playerPaddle.setVelocityY(0);
		}
		// resets ball if it goes off screen and assigns points to objects
		if (gameState.ball.x >= (width - width20)){
			player.score += 1;
			// resets ball
			gameState.ball.x = halfWidth;
			gameState.ball.y = halfHeight;
			gameState.ball.setVelocityY(0);
			gameState.ball.setVelocityX(1000);
			// sets results
			compScore.innerHTML = `Computer's score: ${comp.score}`;
			playerScore.innerHTML = `Your Score: ${player.score}`;
		}
		else if (gameState.ball.x <= width20) {
			comp.score += 1
			//resets ball
			gameState.ball.x = halfWidth;
			gameState.ball.y = halfHeight;
			gameState.ball.setVelocityY(0);
			gameState.ball.setVelocityX(-1000)
			// sets results
			compScore.innerHTML = `Computer's score: ${comp.score}`;
			playerScore.innerHTML = `Your Score: ${player.score}`;
		}
		// computer paddle AI
		if (gameState.ball.y > (gameState.compPaddle.y + 60)) {
			gameState.compPaddle.setVelocityY(500);
		}
		else if (gameState.ball.y < (gameState.compPaddle.y - 60)){
			gameState.compPaddle.setVelocityY(-500);
		}
	}
	else { // runs when game is over
		//sets result values
		playerScore.innerHTML = `Your score: ${player.score}`;
		compScore.innerHTML = `Computer's score: ${comp.score}`;

		// makes game invisible
		gameState.ball.setVisible(false);
		gameState.playerPaddle.setVisible(false);
		gameState.compPaddle.setVisible(false);
		// displays appropriate popup
		if(player.score === 10) {
			gameState.winnerPopup.setVisible(true);
		} else {
			gameState.loserPopup.setVisible(true);
		}

	}
}
</script>
<noscript>
This webpage depends on JavaScript... Please enable Javascript in your browser (enable-javascript.com) or download firefox (mozilla.org/firefox/)
</noscript>
</body>
</html>

